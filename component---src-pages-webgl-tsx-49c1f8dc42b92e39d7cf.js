(self.webpackChunkadam_coogan_github_io=self.webpackChunkadam_coogan_github_io||[]).push([[108,7],{417:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return m}});var a=t(9756),r=t(7294),i=t(2109);var l=t(3297),o=["draw"],u=function(e){var n=e.draw,t=(0,a.Z)(e,o),i=function(e){var n=(0,r.useRef)(null);return(0,r.useEffect)((function(){var t=n.current.getContext("webgl");t||console.log("no webgl!"),e(t)}),[e]),n}(n);return r.createElement("canvas",Object.assign({ref:i},t))},c=function(e){var n=e.label,t=e.value,a=e.set,l=e.min,o=e.max,u=e.description,c=u?r.createElement(r.Fragment,null,r.createElement("label",{style:{flex:2,margin:"0.2rem"},"data-tip":!0,"data-for":u},n),r.createElement(i.Z,{id:u},u)," "):r.createElement("label",{style:{flex:2,margin:"0.2rem"}},n);return r.createElement("div",{style:{display:"flex",alignItems:"center"}},c,r.createElement("input",{style:{flex:1,margin:"0.2rem",minWidth:0},type:"text",min:l,max:o,step:.001,value:t,onChange:function(e){return a(parseFloat(e.target.value))}}),r.createElement("input",{style:{flex:3,margin:"0.2rem"},type:"range",min:l,max:o,step:.001,value:t,onChange:function(e){return a(parseFloat(e.target.value))}}))},s=function(e){var n=e.x,t=e.y,a=e.phiDeg,i=e.q,l=e.index,o=e.r_e,u=e.setX,s=e.setY,_=e.setPhiDeg,f=e.setQ,m=e.setIndex,p=e.setRe;return r.createElement("div",null,r.createElement("h2",null,"Source parameters"),r.createElement(c,{label:"Position (x) ['']",value:n,set:u,min:-2.5,max:2.5}),r.createElement(c,{label:"Position (y) ['']",value:t,set:s,min:-2.5,max:2.5}),r.createElement(c,{label:"Orientation (ϕ) [deg]",value:a,set:_,min:-180,max:180,description:"Orientation of source relative to x-axis"}),r.createElement(c,{label:"Ellipticity (q)",value:i,set:f,min:.15,max:.9999,description:"Controls whether source is circular (q=1) or elliptical (q=0)"}),r.createElement(c,{label:"Index",value:l,set:m,min:.5,max:5,description:"Higher values cause source brightness to decrease sharply with radius"}),r.createElement(c,{label:"Size (r_e) ['']",value:o,set:p,min:1e-4,max:10,description:"Sets the size of the source"}))},_=function(e){var n=e.phiDeg,t=e.q,a=e.r_ein,i=e.setPhiDeg,l=e.setQ,o=e.setRein;return r.createElement("div",null,r.createElement("h2",null,"Lens parameters"),r.createElement(c,{label:"Orientation (ϕ) [deg]",value:n,set:i,min:-180,max:180,description:"Orientation of lens relative to x-axis"}),r.createElement(c,{label:"Ellipticity (q)",value:t,set:l,min:.15,max:.9999,description:"Controls whether lens is circular (q=1) or elliptical (q=0)"}),r.createElement(c,{label:"Einstein radius (r_ein)",value:a,set:o,min:1e-4,max:2.5,description:"Sets the size of the lens"}))},f=function(e){var n=e.sigma_n,t=e.setSigmaN,a=e.setRes;return r.createElement("div",null,r.createElement("h2",null,"Telescope"),r.createElement(c,{label:"Noise level",value:n,set:t,min:0,max:2.5,description:"Telescope noise level"}),r.createElement("div",null,r.createElement("button",{style:{margin:"0.1rem"},onClick:function(){return a(.012)}},"ELT"),r.createElement("button",{style:{margin:"0.1rem"},onClick:function(){return a(.031)}},"JWST"),r.createElement("button",{style:{margin:"0.1rem"},onClick:function(){return a(.05)}},"Hubble Space Telescope"),r.createElement("button",{style:{margin:"0.1rem"},onClick:function(){return a(.1)}},"Euclid"),r.createElement("button",{style:{margin:"0.1rem"},onClick:function(){return a(.7)}},"Rubin Observatory")))},m=function(){var e=(0,r.useState)(.05),n=e[0],t=e[1],a=(0,r.useState)(.1),i=a[0],o=a[1],c=(0,r.useState)(40.107),m=c[0],p=c[1],d=(0,r.useState)(.5),x=d[0],v=d[1],h=(0,r.useState)(4),g=h[0],y=h[1],E=(0,r.useState)(5),S=E[0],b=E[1],R=(0,r.useState)(57.296),q=R[0],L=R[1],P=(0,r.useState)(.75),A=P[0],w=P[1],T=(0,r.useState)(1.5),U=T[0],C=T[1],I=(0,r.useState)(.1),F=I[0],D=I[1],k=(0,r.useState)(0),B=k[0],O=k[1],z=Math.ceil(5/F)*F/2;return r.createElement("div",null,r.createElement(u,{draw:function(e){var t=function(e){var n=(0,l.createShader)(e,e.VERTEX_SHADER,"\nattribute vec2 a_position;\n\nuniform float u_range;\nuniform vec2 u_translation;\n\nvarying vec2 v_xy;\n\nvoid main() {\n  gl_PointSize = 1.0;\n  v_xy = a_position * u_range; // image coordinates\n  gl_Position = vec4(a_position, 0, 1);\n}\n"),t=(0,l.createShader)(e,e.FRAGMENT_SHADER,"\nprecision mediump float;\n\n// Source parameters\nuniform float u_x_s;\nuniform float u_y_s;\nuniform float u_phi_s;\nuniform float u_q_s;\nuniform float u_index;\nuniform float u_r_e;\nuniform float u_I_e;\n// Main lens parameters\nuniform float u_x_l;\nuniform float u_y_l;\nuniform float u_phi_l;\nuniform float u_q_l;\nuniform float u_r_ein;\n// Flux scale\nuniform float u_min_flux;\nuniform float u_max_flux;\n\n// Image positions\nvarying vec2 v_xy;\n\n// From https://www.shadertoy.com/view/WlfXRN\nvec3 viridis(float t) {\n  const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n  const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n  const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n  const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n  const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n  const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n  const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n  return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));\n}\n\nvec4 fluxToRGBA(float flux) {\n  float unclipped = (flux - u_min_flux) / (u_max_flux - u_min_flux);\n  float clipped = step(0.0, unclipped) * step(0.0, 1.0 - unclipped) * unclipped\n      + step(1.0, unclipped);\n  return vec4(viridis(clipped), 1);\n}\n\nfloat sersic(float x, float y) {\n  // Position relative to source\n  float dx = x - u_x_s;\n  float dy = y - u_y_s;\n\n  float k = 2.0 * u_index - 1.0 / 3.0 + 4.0 / 405.0 / u_index + 46.0 / 25515.0 / (u_index * u_index);\n  float x_maj = dx * cos(u_phi_s) + dy * sin(u_phi_s);\n  float x_min = -dx * sin(u_phi_s) + dy * cos(u_phi_s);\n  float r = sqrt(x_maj * x_maj * u_q_s + x_min * x_min / u_q_s) / u_r_e;\n  float exponent = -k * (pow(r, 1.0 / u_index) - 1.0);\n  return u_I_e * exp(exponent);\n}\n\nvec2 alpha_sie(float x, float y) {\n  // Transform to elliptical coordinates\n  float dx = x - u_x_l;\n  float dy = y - u_y_l;\n  float rx = (dx * cos(u_phi_l) + dy * sin(u_phi_l)) * sqrt(u_q_l);\n  float ry = (-dx * sin(u_phi_l) + dy * cos(u_phi_l)) / sqrt(u_q_l);\n  float ang = atan(ry, rx);\n\n  // Deflection field in lens frame\n  float alpha_lf_scale =\n    2.0 *\n    u_r_ein *\n    sqrt(u_q_l / (1.0 - u_q_l * u_q_l)) *\n    atan(sqrt((1.0 - u_q_l) / (1.0 + u_q_l)));\n  float alpha_x_lf = alpha_lf_scale * cos(ang);\n  float alpha_y_lf = alpha_lf_scale * sin(ang);\n\n  // Deflection field in image frame\n  float alpha_x = alpha_x_lf * cos(u_phi_l) - alpha_y_lf * sin(u_phi_l);\n  float alpha_y = alpha_x_lf * sin(u_phi_l) + alpha_y_lf * cos(u_phi_l);\n\n  return vec2(alpha_x, alpha_y);\n}\n\nvoid main() {\n  vec2 xy_lensed = v_xy - alpha_sie(v_xy[0], v_xy[1]);\n  float flux = sersic(xy_lensed[0], xy_lensed[1]);\n  gl_FragColor = fluxToRGBA(flux);\n}\n"),a=(0,l.createProgram)(e,n,t);return(0,l.resizeCanvasToDisplaySize)(e.canvas),e.viewport(0,0,e.canvas.width,e.canvas.height),e.clearColor(0,0,0,.1),e.clear(e.COLOR_BUFFER_BIT),e.useProgram(a),a}(e),a=e.getUniformLocation(t,"u_x_s"),r=e.getUniformLocation(t,"u_y_s"),o=e.getUniformLocation(t,"u_phi_s"),u=e.getUniformLocation(t,"u_q_s"),c=e.getUniformLocation(t,"u_index"),s=e.getUniformLocation(t,"u_r_e"),_=e.getUniformLocation(t,"u_I_e");e.uniform1f(a,n),e.uniform1f(r,i),e.uniform1f(o,m*Math.PI/180),e.uniform1f(u,x),e.uniform1f(c,g),e.uniform1f(s,S),e.uniform1f(_,.05);var f=e.getUniformLocation(t,"u_x_l"),p=e.getUniformLocation(t,"u_y_l"),d=e.getUniformLocation(t,"u_phi_l"),v=e.getUniformLocation(t,"u_q_l"),h=e.getUniformLocation(t,"u_r_ein");e.uniform1f(f,0),e.uniform1f(p,0),e.uniform1f(d,q*Math.PI/180),e.uniform1f(v,A),e.uniform1f(h,U);var y=e.getUniformLocation(t,"u_range");e.uniform1f(y,z);var E=e.getUniformLocation(t,"u_min_flux"),b=e.getUniformLocation(t,"u_max_flux");e.uniform1f(E,-3),e.uniform1f(b,18);var R=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,R);var L=e.getAttribLocation(t,"a_position");e.bindBuffer(e.ARRAY_BUFFER,R),e.vertexAttribPointer(L,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(L),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),e.STATIC_DRAW),e.drawArrays(e.TRIANGLE_STRIP,0,4)},width:500,height:500}),r.createElement(s,{x:n,y:i,phiDeg:m,q:x,index:g,r_e:S,setX:t,setY:o,setPhiDeg:p,setQ:v,setIndex:y,setRe:b}),r.createElement(_,{phiDeg:q,q:A,r_ein:U,setPhiDeg:L,setQ:w,setRein:C}),r.createElement(f,{sigma_n:B,setSigmaN:O,setRes:D}))}},3297:function(e,n,t){"use strict";t.r(n),t.d(n,{createShader:function(){return a},createProgram:function(){return r},resizeCanvasToDisplaySize:function(){return i}});var a=function(e,n,t){var a=e.createShader(n);if(e.shaderSource(a,t),e.compileShader(a),e.getShaderParameter(a,e.COMPILE_STATUS))return a;console.log(e.getShaderInfoLog(a)),e.deleteShader(a)},r=function(e,n,t){var a=e.createProgram();if(e.attachShader(a,n),e.attachShader(a,t),e.linkProgram(a),e.getProgramParameter(a,e.LINK_STATUS))return a;console.log(e.getProgramInfoLog(a)),e.deleteProgram(a)},i=function(e){var n=e.clientWidth,t=e.clientHeight,a=e.width!==n||e.height!==t;return a&&(e.width=n,e.height=t),a}}}]);
//# sourceMappingURL=component---src-pages-webgl-tsx-49c1f8dc42b92e39d7cf.js.map